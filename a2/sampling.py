#############################################################################
### Търсене и извличане на информация. Приложение на дълбоко машинно обучение
### Стоян Михов
### Зимен семестър 2025/2026
#############################################################################
###
### Домашно задание 2 -- функции за семплиране на думи
###
#############################################################################

import random
import numpy as np


#############################################################
###  Случайна извадка от негативни примери --
###  избира от зададена последователност за семплиране seq
###  negativesCount на брой негативни примери различни от c.
###  Връща списък, който съдържа на първа позиция c, а на следващите
###  negativesCount позиции -- негативни примери различни от c
#############################################################
def sampleContext(c, seq, negativesCount):
    context = [c]
    while len(context) <= negativesCount:
        cn = random.choice(seq)
        if cn != c:
            context.append(cn)
    return context


#############################################################
###  Създаване на последователност за семплиране
#############################################################
def createSamplingSequence(freqs):
    #############################################################
    ###  Списъкът freqs съдържа на позиция i броя на срещанията на терма с индекс i.
    ###  Функцията връща списък seq, в който броят на срещанията на даден индекс на терм
    ###  е пропорционален на желаната вероятност (Вижте опътването в заданието).
    #############################################################

    #############################################################################
    #### Начало на Вашия код. На мястото на pass се очакват 3-7 реда

    weights = [int(round(f**0.75)) for f in freqs]
    seq = []
    for i, w in enumerate(weights):
        if w > 0:
            seq.extend([i] * w)

    #### Край на Вашия код
    #############################################################################
    return seq


#############################################################
###  Създаване на последователност за семплиране
#############################################################
def noiseDistribution(freqs, negativesCount):
    #############################################################
    ###  Списъкът freq съдържа на позиция i броя на срещанията на терма с индекс i.
    ###  Функцията връща вектор q_noise, с дължина броя на думите в речника, в който
    ###  на позиция  i стойността следва да е логаритъм от negativesCount по вероятността
    ###  на терма с индекс i (Вижте опътването в заданието).
    #############################################################

    #############################################################################
    #### Начало на Вашия код. На мястото на pass се очакват 3-7 реда

    weights = np.array([int(round(f**0.75)) for f in freqs], dtype=float)
    total = weights.sum()
    p = weights / total  # q[c]
    q_noise = np.log(negativesCount * p)

    #### Край на Вашия код
    #############################################################################
    return q_noise
